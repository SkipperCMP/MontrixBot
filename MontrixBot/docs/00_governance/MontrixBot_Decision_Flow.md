# MontrixBot — Decision Flow

## Назначение документа

Данный документ описывает **рабочий порядок принятия решений** в проекте MontrixBot.

Он **не является управляющим документом** и **не вводит новых правил**.  
Его задача — зафиксировать **последовательность мышления и проверок**,  
которой следует придерживаться при:

- появлении новой идеи,
- обнаружении проблемы или дефекта,
- предложении изменений в коде, архитектуре или поведении системы.

Decision Flow не может использоваться
как основание для изменения правил,
архитектуры или Roadmap.

Он служит исключительно
порядком проверки допустимости решений,
а не источником этих решений.

Decision Flow служит **операционным мостом** между:
- идеями и реализацией,
- документацией и практикой,
- текущим состоянием проекта и его будущим развитием.

Guard Rails обеспечивают наблюдаемость, трассируемость и диагностику безопасности.
Они не являются gate-механизмами исполнения и не выдают разрешений
и не запрещают выполнение действий.

---

## Базовый принцип

Ни одно изменение в MontrixBot не начинается с реализации.

Любое изменение начинается с **осознанного решения**,  
прошедшего последовательную проверку допустимости.

Decision Flow:
- не может использоваться как аргумент допустимости изменений,
- не заменяет Governance, Roadmap или Rules,
- не может легализовать изменения,
  недопустимые по Master Roadmap.

---

## Шаг 1. Формулировка изменения

Перед любыми действиями изменение должно быть сформулировано **одним предложением**.

Формулировка обязана отвечать на вопрос:

> *Что именно изменится в поведении системы или в её структуре?*

Если формулировка:
- размыта,
- содержит несколько целей,
- описывает «как», а не «что»,

изменение считается **неподготовленным**.

---

## Шаг 2. Классификация изменения

Каждое изменение **обязано** быть отнесено к одному из типов:

- PATCH  
- FEATURE  
- REFACTOR  
- IMPROVEMENT  
- ARCHITECTURAL CHANGE  
- ROLLBACK STEP  

Классификация выполняется **до начала реализации**.

Если классификация вызывает сомнение,  
изменение рассматривается как **более опасный тип**, а не более простой.

---

## Шаг 3. Проверка по Governance

После классификации выполняется проверка по иерархии документов:

1. Соответствует ли изменение **Internal Vision**
2. Допустимо ли оно текущим **Master Roadmap**
3. Присутствует ли оно в **Product Roadmap** (если это FEATURE)
4. Может ли оно быть реализовано в рамках **Master Rules**

Если хотя бы на одном уровне получен отрицательный ответ,
изменение считается **недопустимым** в текущем виде.

---

## Шаг 4. Проверка STEP-контекста

Любое изменение проверяется в контексте **текущего ACTIVE STEP**:

- находится ли изменение **в пределах назначения STEP**
- не расширяет ли оно STEP задним числом
- не нарушает ли ограничений STEP

Изменение, допустимое концептуально,  
может быть **временно недопустимым** из-за стадии проекта.

---

## Шаг 5. Проверка архитектурных границ

Перед реализацией необходимо ответить на вопросы:

- меняются ли границы ответственности компонентов
- затрагиваются ли Core / UI / State / Executor
- меняются ли контракты взаимодействия
- появляется ли скрытая зависимость между слоями
- затрагивается ли SIM → REAL канал
- не превращаются ли ScoutNotes
  в скрытые сигналы или команды
- сохраняется ли корректность REAL
  при SIM = OFF
- расширяет ли изменение UI control-surface (новые кнопки/режимы),
  и не создаёт ли двусмысленность управления SIM/REAL
- добавляет ли изменение индикаторы,
  и не нарушает ли оно разделение
  SIM (research) и REAL (execution)

Если хотя бы один ответ положительный,
изменение **не может считаться простым**  
и обязано быть переклассифицировано.

Если изменение нарушает
REAL Independence Invariant
или ScoutNote Contract,
оно считается архитектурно недопустимым
и должно быть отклонено
или переформулировано.

Аналитические выводы SIM рассматриваются как наблюдения,
а не как решения или команды к исполнению.

---

## Шаг 6. Решение о реализации

По результатам предыдущих шагов принимается одно из решений:

- **Разрешено к реализации** в текущем STEP
- **Отложено** до другого STEP или версии
- **Отклонено** как недопустимое направление
- **Требует переформулировки** и повторного прохода Decision Flow

Реализация без прохождения Decision Flow
считается нарушением Governance проекта.

---

## Шаг 7. Реализация и фиксация

Если изменение разрешено:

- оно реализуется **строго в рамках заявленной классификации**
- не выходит за границы проверок
- не расширяется «по ходу дела»

После завершения:

- фиксируется результат (baseline, patch, commit)
- при необходимости обновляется сопутствующая документация

---

## Принцип предосторожности

При любом сомнении:

- предпочтение отдаётся **безопасности**, а не скорости
- предпочтение отдаётся **остановке**, а не действию
- предпочтение отдаётся **наблюдаемости**, а не автоматизации

Decision Flow допускает отказ от изменения
как корректный и осознанный результат.

---

## Итог

Decision Flow существует для того, чтобы:

- проект оставался управляемым на дистанции лет,
- решения не принимались импульсивно,
- архитектурная целостность не деградировала со временем,
- возвращение к проекту было предсказуемым и безопасным.

Этот документ не ускоряет разработку.  
Он **защищает проект от ошибок роста**.

Decision Flow не гарантирует правильность решения.  
Он гарантирует, что решение принято осознанно.
