Master Rules применяются ко всем сущностям проекта,
включая:

- стратегии (см. Strategies Canon)
- SIM и его аналитические выходы
- UI control-surface
- Policy Engine и Safe Mode
- любые изменения, проходящие Decision Flow

Ни один контракт или спецификация
не может ослаблять данные инварианты.

MontrixBot_MasterRules не определяет управление проектом.
Он задаёт ограничения и инварианты реализации
в рамках решений, уже принятых по Governance.

# MontrixBot — Master Rules

## Назначение документа

Данный документ определяет **обязательные архитектурные, процессные и эксплуатационные правила**
проекта MontrixBot.

Master Rules **НЕ описывает продуктовые фичи, стратегии или пользовательское поведение**.
Его задача — зафиксировать:

- архитектурные ограничения,
- правила взаимодействия компонентов,
- требования к стабильности и безопасности,
- процессные стандарты разработки.

---

## Связь с Governance

Master Rules не являются документом управления проектом.

Они задают архитектурные инварианты и ограничения реализации
для решений, уже допустимых
в рамках Governance и текущего STEP.

Master Rules не могут:
- разрешать новые направления развития,
- менять Roadmap,
- вводить стратегические цели.

---

## Граница аналитики SIM

SIM может вычислять любые индикаторы, метрики и аналитические показатели.

Результаты работы SIM носят исключительно наблюдательный характер
и могут передаваться наружу только в форме ScoutNotes.

SIM не имеет права:
- формировать торговые сигналы
- управлять стратегиями
- изменять поведение REAL

---

## 0. Актуальная модель дорожных карт

Модель Roadmap A / Roadmap B считается **исторической** и более не используется.

Актуальная система планирования проекта:

- **Product Roadmap** — определяет продуктовое содержание (что и когда строится)
- **Master Roadmap** — определяет допустимость, порядок и архитектурные границы
- **Internal Vision** — внутренний ориентир направления развития (non-binding)

Любые ссылки на альтернативные или расширенные roadmap’ы считаются устаревшими.

---

## 1. Базовые определения

- **SSOT (Single Source of Truth)** — State Engine является единственным источником истины.
- **Core** — торговое и управляющее ядро системы.
- **UI** — отображающий слой, не содержащий бизнес-логики.
- **SIM / REAL** — режимы исполнения с разным уровнем риска.
- **Baseline** — зафиксированное стабильное состояние проекта.
- **Safe Mode** — защитный режим, блокирующий опасные действия.

---

## 2. Архитектурные правила (HARD)

### 2.1 Разделение Core и UI

- UI **не имеет права** напрямую вызывать Core.
- UI **не читает** runtime-файлы и состояние напрямую.
- Все взаимодействия проходят **исключительно через UIAPI**.
- UI является **display-only** слоем.

#### UI Control Surface (HARD)

UI допускает только следующие управляющие действия верхнего уровня:

- SIM Start / SIM Stop — управление активностью SIM (анализ, сигналы, ScoutNotes).
- REAL Start / REAL Stop — управление разрешением исполнения REAL
  (семантика: ARM / DISARM, а не запуск/остановка процесса).

UI не должен содержать переключателей "Mode: SIM/REAL" как управляющего элемента.
Выбор контекста отображения допускается,
но он не является режимом системы и не должен менять поведение Core напрямую.

Компоненты "REAL CLI" и "Dry-Run" не допускаются в основном UI control-surface.
Если они существуют, они относятся к debug/dev-инструментам
и должны быть изолированы от пользовательского UX.

Нарушение данного правила считается **критической архитектурной ошибкой**.

---

### 2.2 State Engine (SSOT)

- State Engine — **единственный источник истины**.
- Любое дублирование состояния запрещено.
- UI и сервисы работают **только со снапшотами**.

---

### 2.3 SIM / REAL изоляция

- SIM и REAL полностью изолированы логически.
- REAL-режим не может зависеть от SIM
  как обязательного источника данных или решений.
- SIM всегда безопаснее REAL.
- Ошибка в SIM не может повлиять на REAL.

Допускается односторонняя передача
наблюдательных и аналитических артефактов
из SIM в REAL в форме рекомендаций,
кандидатов или разведывательных заметок,
при условии что:

- они не являются командами,
- не содержат инструкций исполнения,
- могут быть полностью проигнорированы REAL,
- отсутствие SIM не нарушает корректность REAL.

SIM не управляет REAL напрямую
и не является частью цепочки принятия торговых решений.

Форма и ограничения допустимого
SIM → REAL взаимодействия
строго регламентируются:

- ScoutNote Contract
- SIM → REAL Anti-Spam Policy
- REAL Independence Invariant

Любое отклонение от данных норм
считается критическим нарушением
архитектурной изоляции.

#### Indicator Separation (HARD)

SIM допускает использование расширенного набора индикаторов,
эвристик, статистических методов и аналитических алгоритмов
для исследования рынка, поиска аномалий и формирования контекста.

REAL обязан использовать минимально достаточный набор индикаторов,
необходимый исключительно для:
- определения рыночного режима (market regime),
- детерминированного триггера входа,
- управления риском и выхода из позиции.

Передача из SIM в REAL любых индикаторов,
их значений, производных метрик
или агрегированных сигналов запрещена.

SIM → REAL допускает только наблюдательные артефакты
в форме ScoutNotes, не содержащие:
- числовых значений индикаторов,
- торговых условий,
- инструкций исполнения.

Нарушение данного правила
считается критическим нарушением
SIM / REAL изоляции.

---

### 2.4 TPSL Loop

- TPSL Loop полностью автономен.
- TPSL Loop **не зависит от UI**.
- TPSL Loop продолжает работать при деградации интерфейса.

---

### 2.5 Safe Mode

- Safe Mode принадлежит Core.
- UI **не может** управлять Safe Mode напрямую.
- При активации Safe Mode:
  - REAL-блокируется,
  - SIM разрешён,
  - автоматические действия останавливаются.

---

### 2.6 SIM → REAL Observational Channel (HARD)

- ScoutNote Contract
- SIM → REAL Anti-Spam Policy
- REAL Independence Invariant
- Ownership / Write-Permissions Matrix

Набор аналитических индикаторов и форматов рекомендаций SIM
описан в MontrixBot_SIM_Analytical_Framework.md.

Данный документ является вспомогательным
и не изменяет инварианты SIM / REAL,
зафиксированные в MasterRules.

---

## 3. Процессные правила (PROCESS)

### 3.1 STEP-дисциплина

- Разработка ведётся **строго в рамках активного STEP**.
- Переход к следующему STEP возможен только после:
  - закрытия долгов,
  - фиксации baseline,
  - стабилизации системы.

---

### 3.2 Изменения и патчи

- Любой патч должен:
  - иметь чёткую цель,
  - не нарушать архитектурных границ,
  - быть обратимым.

- Временные хаки запрещены.
- Исключения допустимы только с явной пометкой и последующим удалением.

---
### 3.2.1 Требования к патчам

Любой PATCH в проекте MontrixBot обязан удовлетворять следующим требованиям:

1. PATCH имеет одну чёткую цель.
2. PATCH не добавляет новой функциональности.
3. PATCH не расширяет архитектурные границы системы.
4. PATCH является обратимым.
5. PATCH не меняет контрактов Core, UIAPI или State Engine.

PATCH запрещено использовать для:
- добавления нового поведения;
- изменения продуктовой логики;
- компенсации архитектурных ошибок через временные хаки.

Если в ходе реализации PATCH выявляется необходимость:
- изменения поведения,
- изменения архитектуры,
- расширения функциональности,

PATCH обязан быть остановлен и переклассифицирован.

---

### 3.2.2 Ограничения по типам изменений

**REFACTOR**
- не меняет внешнее поведение системы;
- не изменяет контракты Core, UIAPI, State Engine;
- не допускается в период нестабильности STEP;
- запрещён, если используется для скрытого изменения логики.

**IMPROVEMENT (улучшение)**

IMPROVEMENT — это изменение, которое:
- улучшает качество существующего поведения или UX;
- не вводит новый пользовательский сценарий;
- не расширяет архитектурные границы системы;
- не меняет назначение и смысл STEP.

Ограничения:
- IMPROVEMENT допустим **только внутри ACTIVE STEP**;
- IMPROVEMENT **запрещён** после фиксации baseline STEP;
- IMPROVEMENT не может изменять контракты Core, UIAPI, State Engine;
- IMPROVEMENT не может использоваться для компенсации ошибок проектирования.

Если улучшение:
- меняет поведение,
- добавляет новый сценарий,
- требует архитектурных изменений,

оно обязано быть **переклассифицировано** в FEATURE или ARCHITECTURAL CHANGE.

**ARCHITECTURAL CHANGE**
- допустим только внутри ACTIVE STEP;
- требует предварительной классификации и явной фиксации последствий;
- запрещён после фиксации baseline STEP.

Любое изменение, выходящее за эти рамки,
обязано быть остановлено и переклассифицировано.

---

### 3.3 Наблюдаемость и стабильность

- Любой компонент обязан быть наблюдаемым.
- Отсутствие сигналов ≠ нормальное состояние.
- Система должна предпочитать **остановку принятия решений**, а не неконтролируемое поведение.
- Наблюдаемость должна быть реализована в форме, совместимой с архитектурой снапшотов и без зависимости UI от файлов.

---

## 4. Эксплуатационные принципы (OPERATIONAL)

### 4.1 Поведение по умолчанию (NON-BINDING)

Следующие положения описывают **текущие ориентиры эксплуатации**  
и **НЕ являются архитектурными требованиями**.

Они могут изменяться по мере развития продукта.

- SIM используется как режим по умолчанию.
- Ограничения риска и просадки должны быть **явно заданы и конфигурируемы**.
- Торговое поведение определяется продуктовой логикой, а не данным документом.

---

### 4.2 Числовые значения

- Все числовые лимиты:
  - считаются ориентировочными,
  - не являются догмой,
  - должны быть параметризуемыми.

Жёсткая фиксация значений в Master Rules запрещена.

### 4.3 Автономное принятие решений

- Автономные решения должны быть полностью наблюдаемыми.
- Система обязана иметь возможность принять решение не торговать.
- Любое автономное действие должно быть немедленно прерываемо Safe Mode.
- Автономные компоненты не имеют права изменять собственную логику.
- При неопределённости предпочтение всегда отдаётся бездействию.

---

## 5. Anti-Overheat & Safety Principles

- Система должна уметь:
  - безопасно остановиться,
  - сохранить состояние,
  - продолжить наблюдение.

- При сомнении:
  - приоритет отдаётся **безопасности**, а не выгоде.
- Ошибки логики считаются опаснее ошибок интерфейса.

---

## 6. Связь с другими документами

- Product Roadmap определяет **что строится**.
- Master Roadmap определяет **когда и можно ли это строить**.
- Internal Vision определяет **вектор развития**.
- Master Rules определяет **как это должно быть реализовано безопасно**.

Набор аналитических индикаторов SIM
описан в MontrixBot_SIM_Analytical_Framework.md.

Ни один документ не дублирует другой.

---

## Итог

Master Rules — это **набор обязательных ограничений**,  
а не список желаемого поведения системы.

Он:
- защищает архитектуру,
- предотвращает деградацию,
- допускает развитие,
- не фиксирует продукт навсегда.

Любые изменения Master Rules требуют осознанного пересмотра
и должны рассматриваться как изменения конституционного уровня.
